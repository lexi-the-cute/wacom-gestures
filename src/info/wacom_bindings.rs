#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

/* automatically generated by rust-bindgen 0.66.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const WACOM_STYLUS_FALLBACK_ID: u32 = 1048575;
pub const WACOM_ERASER_FALLBACK_ID: u32 = 1048574;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WacomDevice {
    _unused: [u8; 0],
}
#[doc = " @ingroup devices"]
pub type WacomDevice = _WacomDevice;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WacomMatch {
    _unused: [u8; 0],
}
#[doc = " @ingroup devices"]
pub type WacomMatch = _WacomMatch;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WacomStylus {
    _unused: [u8; 0],
}
#[doc = " @ingroup styli"]
pub type WacomStylus = _WacomStylus;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WacomError {
    _unused: [u8; 0],
}
#[doc = " @ingroup context"]
pub type WacomError = _WacomError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WacomDeviceDatabase {
    _unused: [u8; 0],
}
#[doc = " @ingroup context"]
pub type WacomDeviceDatabase = _WacomDeviceDatabase;
#[doc = "< No error has occured"]
pub const WacomErrorCode_WERROR_NONE: WacomErrorCode = 0;
#[doc = "< Allocation error"]
pub const WacomErrorCode_WERROR_BAD_ALLOC: WacomErrorCode = 1;
#[doc = "< A path specified is invalid"]
pub const WacomErrorCode_WERROR_INVALID_PATH: WacomErrorCode = 2;
#[doc = "< The passed DB is invalid"]
pub const WacomErrorCode_WERROR_INVALID_DB: WacomErrorCode = 3;
#[doc = "< Invalid permissions to access the path"]
pub const WacomErrorCode_WERROR_BAD_ACCESS: WacomErrorCode = 4;
#[doc = "< Unsupported/unknown device"]
pub const WacomErrorCode_WERROR_UNKNOWN_MODEL: WacomErrorCode = 5;
#[doc = "< A bug in the caller"]
pub const WacomErrorCode_WERROR_BUG_CALLER: WacomErrorCode = 6;
#[doc = " Possible error codes.\n\n @ingroup context"]
pub type WacomErrorCode = ::std::os::raw::c_uint;
#[doc = "< Unknown/unsupported bus type"]
pub const WacomBusType_WBUSTYPE_UNKNOWN: WacomBusType = 0;
#[doc = "< USB tablet"]
pub const WacomBusType_WBUSTYPE_USB: WacomBusType = 1;
#[doc = "< Serial tablet"]
pub const WacomBusType_WBUSTYPE_SERIAL: WacomBusType = 2;
#[doc = "< Bluetooth tablet"]
pub const WacomBusType_WBUSTYPE_BLUETOOTH: WacomBusType = 3;
#[doc = "< I2C tablet"]
pub const WacomBusType_WBUSTYPE_I2C: WacomBusType = 4;
#[doc = " Bus types for tablets.\n\n @ingroup devices"]
pub type WacomBusType = ::std::os::raw::c_uint;
pub const WacomIntegrationFlags_WACOM_DEVICE_INTEGRATED_NONE: WacomIntegrationFlags = 0;
pub const WacomIntegrationFlags_WACOM_DEVICE_INTEGRATED_DISPLAY: WacomIntegrationFlags = 1;
pub const WacomIntegrationFlags_WACOM_DEVICE_INTEGRATED_SYSTEM: WacomIntegrationFlags = 2;
#[doc = " Tablet integration.\n\n @ingroup devices"]
pub type WacomIntegrationFlags = ::std::os::raw::c_uint;
#[doc = "< Unknown/unsupported device class"]
pub const WacomClass_WCLASS_UNKNOWN: WacomClass = 0;
#[doc = "< Any Intuos3 series"]
pub const WacomClass_WCLASS_INTUOS3: WacomClass = 1;
#[doc = "< Any Intuos4 series"]
pub const WacomClass_WCLASS_INTUOS4: WacomClass = 2;
#[doc = "< Any Intuos5 series"]
pub const WacomClass_WCLASS_INTUOS5: WacomClass = 3;
#[doc = "< Any Cintiq device"]
pub const WacomClass_WCLASS_CINTIQ: WacomClass = 4;
#[doc = "< Any Bamboo device"]
pub const WacomClass_WCLASS_BAMBOO: WacomClass = 5;
#[doc = "< Any Graphire device"]
pub const WacomClass_WCLASS_GRAPHIRE: WacomClass = 6;
#[doc = "< Any serial ISDV4 device"]
pub const WacomClass_WCLASS_ISDV4: WacomClass = 7;
#[doc = "< Any Intuos series"]
pub const WacomClass_WCLASS_INTUOS: WacomClass = 8;
#[doc = "< Any Intuos2 series"]
pub const WacomClass_WCLASS_INTUOS2: WacomClass = 9;
#[doc = "< Any \"interactive pen display\""]
pub const WacomClass_WCLASS_PEN_DISPLAYS: WacomClass = 10;
#[doc = "< Any Wacom Remote"]
pub const WacomClass_WCLASS_REMOTE: WacomClass = 11;
#[doc = " Classes of devices.\n\n @deprecated This enum should no longer be used. The classes are not\n fine-grained or reliable enough to be useful.\n\n @ingroup devices"]
pub type WacomClass = ::std::os::raw::c_uint;
pub const WacomStylusType_WSTYLUS_UNKNOWN: WacomStylusType = 0;
pub const WacomStylusType_WSTYLUS_GENERAL: WacomStylusType = 1;
pub const WacomStylusType_WSTYLUS_INKING: WacomStylusType = 2;
pub const WacomStylusType_WSTYLUS_AIRBRUSH: WacomStylusType = 3;
pub const WacomStylusType_WSTYLUS_CLASSIC: WacomStylusType = 4;
pub const WacomStylusType_WSTYLUS_MARKER: WacomStylusType = 5;
pub const WacomStylusType_WSTYLUS_STROKE: WacomStylusType = 6;
pub const WacomStylusType_WSTYLUS_PUCK: WacomStylusType = 7;
pub const WacomStylusType_WSTYLUS_3D: WacomStylusType = 8;
pub const WacomStylusType_WSTYLUS_MOBILE: WacomStylusType = 9;
#[doc = " Class of stylus\n\n @ingroup styli"]
pub type WacomStylusType = ::std::os::raw::c_uint;
pub const WacomEraserType_WACOM_ERASER_UNKNOWN: WacomEraserType = 0;
#[doc = "< No eraser is present on the stylus"]
pub const WacomEraserType_WACOM_ERASER_NONE: WacomEraserType = 1;
#[doc = "< Eraser is a separate tool on the opposite end of the stylus"]
pub const WacomEraserType_WACOM_ERASER_INVERT: WacomEraserType = 2;
#[doc = "< Eraser is a button alongside any other stylus buttons"]
pub const WacomEraserType_WACOM_ERASER_BUTTON: WacomEraserType = 3;
#[doc = " Type of eraser on a stylus\n\n @ingroup styli"]
pub type WacomEraserType = ::std::os::raw::c_uint;
pub const WacomButtonFlags_WACOM_BUTTON_NONE: WacomButtonFlags = 0;
pub const WacomButtonFlags_WACOM_BUTTON_POSITION_LEFT: WacomButtonFlags = 2;
pub const WacomButtonFlags_WACOM_BUTTON_POSITION_RIGHT: WacomButtonFlags = 4;
pub const WacomButtonFlags_WACOM_BUTTON_POSITION_TOP: WacomButtonFlags = 8;
pub const WacomButtonFlags_WACOM_BUTTON_POSITION_BOTTOM: WacomButtonFlags = 16;
pub const WacomButtonFlags_WACOM_BUTTON_RING_MODESWITCH: WacomButtonFlags = 32;
pub const WacomButtonFlags_WACOM_BUTTON_RING2_MODESWITCH: WacomButtonFlags = 64;
pub const WacomButtonFlags_WACOM_BUTTON_TOUCHSTRIP_MODESWITCH: WacomButtonFlags = 128;
pub const WacomButtonFlags_WACOM_BUTTON_TOUCHSTRIP2_MODESWITCH: WacomButtonFlags = 256;
pub const WacomButtonFlags_WACOM_BUTTON_OLED: WacomButtonFlags = 512;
pub const WacomButtonFlags_WACOM_BUTTON_MODESWITCH: WacomButtonFlags = 480;
pub const WacomButtonFlags_WACOM_BUTTON_DIRECTION: WacomButtonFlags = 30;
pub const WacomButtonFlags_WACOM_BUTTON_RINGS_MODESWITCH: WacomButtonFlags = 96;
pub const WacomButtonFlags_WACOM_BUTTON_TOUCHSTRIPS_MODESWITCH: WacomButtonFlags = 384;
#[doc = " Capabilities of the various tablet buttons\n\n @ingroup devices"]
pub type WacomButtonFlags = ::std::os::raw::c_uint;
pub const WacomAxisTypeFlags_WACOM_AXIS_TYPE_NONE: WacomAxisTypeFlags = 0;
#[doc = " Tilt in x and y direction"]
pub const WacomAxisTypeFlags_WACOM_AXIS_TYPE_TILT: WacomAxisTypeFlags = 2;
#[doc = " Rotation in the z-axis"]
pub const WacomAxisTypeFlags_WACOM_AXIS_TYPE_ROTATION_Z: WacomAxisTypeFlags = 4;
#[doc = " Distance to surface"]
pub const WacomAxisTypeFlags_WACOM_AXIS_TYPE_DISTANCE: WacomAxisTypeFlags = 8;
#[doc = " Tip pressure"]
pub const WacomAxisTypeFlags_WACOM_AXIS_TYPE_PRESSURE: WacomAxisTypeFlags = 16;
#[doc = " A absolute-position slider like the wheel on the airbrush"]
pub const WacomAxisTypeFlags_WACOM_AXIS_TYPE_SLIDER: WacomAxisTypeFlags = 32;
#[doc = " Axis type for a stylus. Note that x/y is implied.\n\n @ingroup styli"]
pub type WacomAxisTypeFlags = ::std::os::raw::c_uint;
pub const WacomFallbackFlags_WFALLBACK_NONE: WacomFallbackFlags = 0;
pub const WacomFallbackFlags_WFALLBACK_GENERIC: WacomFallbackFlags = 1;
#[doc = " @ingroup devices"]
pub type WacomFallbackFlags = ::std::os::raw::c_uint;
#[doc = "< compare the device only"]
pub const WacomCompareFlags_WCOMPARE_NORMAL: WacomCompareFlags = 0;
#[doc = "< compare all possible matches too"]
pub const WacomCompareFlags_WCOMPARE_MATCHES: WacomCompareFlags = 2;
#[doc = " @ingroup devices"]
pub type WacomCompareFlags = ::std::os::raw::c_uint;
pub const WacomStatusLEDs_WACOM_STATUS_LED_UNAVAILABLE: WacomStatusLEDs = -1;
pub const WacomStatusLEDs_WACOM_STATUS_LED_RING: WacomStatusLEDs = 0;
pub const WacomStatusLEDs_WACOM_STATUS_LED_RING2: WacomStatusLEDs = 1;
pub const WacomStatusLEDs_WACOM_STATUS_LED_TOUCHSTRIP: WacomStatusLEDs = 2;
pub const WacomStatusLEDs_WACOM_STATUS_LED_TOUCHSTRIP2: WacomStatusLEDs = 3;
#[doc = " @ingroup devices"]
pub type WacomStatusLEDs = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Allocate a new structure for error reporting.\n\n @return A newly allocated error structure or NULL if the allocation\n failed.\n\n @ingroup context"]
    pub fn libwacom_error_new() -> *mut WacomError;
}
extern "C" {
    #[doc = " Free the error and associated memory.\n Resets error to NULL.\n\n @param error A reference to a error struct.\n @see libwacom_error_new\n\n @ingroup context"]
    pub fn libwacom_error_free(error: *mut *mut WacomError);
}
extern "C" {
    #[doc = " @return The code for this error.\n\n @ingroup context"]
    pub fn libwacom_error_get_code(error: *mut WacomError) -> WacomErrorCode;
}
extern "C" {
    #[doc = " @return A human-readable message for this error\n\n @ingroup context"]
    pub fn libwacom_error_get_message(error: *mut WacomError) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Loads the Tablet and Stylus databases, to be used\n in libwacom_new_*() functions.\n\n @return A new database or NULL on error.\n\n @ingroup context"]
    pub fn libwacom_database_new() -> *mut WacomDeviceDatabase;
}
extern "C" {
    #[doc = " Loads the Tablet and Stylus databases, to be used\n in libwacom_new_*() functions, from the prefix\n path passes. This is only useful for diagnostics\n applications.\n\n @return A new database or NULL on error.\n\n @ingroup context"]
    pub fn libwacom_database_new_for_path(
        datadir: *const ::std::os::raw::c_char,
    ) -> *mut WacomDeviceDatabase;
}
extern "C" {
    #[doc = " Free all memory used by the database.\n\n @param db A Tablet and Stylus database.\n\n @ingroup context"]
    pub fn libwacom_database_destroy(db: *mut WacomDeviceDatabase);
}
extern "C" {
    #[doc = " Create a new device reference from the given device path.\n In case of error, NULL is returned and the error is set to the\n appropriate value.\n\n @param db A device database\n @param path A device path in the form of e.g. /dev/input/event0\n @param fallback Whether we should create a generic if model is unknown\n @param error If not NULL, set to the error if any occurs\n\n @return A new reference to this device or NULL on errror.\n\n @ingroup devices"]
    pub fn libwacom_new_from_path(
        db: *const WacomDeviceDatabase,
        path: *const ::std::os::raw::c_char,
        fallback: WacomFallbackFlags,
        error: *mut WacomError,
    ) -> *mut WacomDevice;
}
extern "C" {
    #[doc = " Create a new device reference from the given vendor/product IDs.\n In case of error, NULL is returned and the error is set to the\n appropriate value.\n\n @note The term \"usbid\" is misleading, this function will return\n devices with matching ids on the USB, Bluetooth or i2c bus.\n\n @param db A device database\n @param vendor_id The vendor ID of the device\n @param product_id The product ID of the device\n @param error If not NULL, set to the error if any occurs\n\n @return A new reference to this device or NULL on errror.\n\n @ingroup devices"]
    pub fn libwacom_new_from_usbid(
        db: *const WacomDeviceDatabase,
        vendor_id: ::std::os::raw::c_int,
        product_id: ::std::os::raw::c_int,
        error: *mut WacomError,
    ) -> *mut WacomDevice;
}
extern "C" {
    #[doc = " Create a new device reference from the given name.\n In case of error, NULL is returned and the error is set to the\n appropriate value.\n\n @param db A device database\n @param name The name identifying the device\n @param error If not NULL, set to the error if any occurs\n\n @return A new reference to this device or NULL on error.\n\n @ingroup devices"]
    pub fn libwacom_new_from_name(
        db: *const WacomDeviceDatabase,
        name: *const ::std::os::raw::c_char,
        error: *mut WacomError,
    ) -> *mut WacomDevice;
}
extern "C" {
    #[doc = " Returns the list of devices in the given database.\n\n @param db A device database\n @param error If not NULL, set to the error if any occurs\n\n @return A NULL terminated list of pointers to all the devices inside the\n database.\n The content of the list is owned by the database and should not be\n modified or freed. Use free() to free the list.\n\n @ingroup devices"]
    pub fn libwacom_list_devices_from_database(
        db: *const WacomDeviceDatabase,
        error: *mut WacomError,
    ) -> *mut *mut WacomDevice;
}
extern "C" {
    #[doc = " Print the description of this device to the given file.\n\n @param fd The file descriptor to print to\n @param device The device to print the description for.\n\n @ingroup devices"]
    pub fn libwacom_print_device_description(fd: ::std::os::raw::c_int, device: *const WacomDevice);
}
extern "C" {
    #[doc = " Remove the device and free all memory and references to it.\n\n @param device The device to delete\n\n @ingroup devices"]
    pub fn libwacom_destroy(device: *mut WacomDevice);
}
extern "C" {
    #[doc = " Compare the two devices for equal-ness.\n\n @param a The first device\n @param b The second device\n @param flags Flags to dictate what constitutes a match\n\n @return 0 if the devices are identical, nonzero otherwise\n\n @ingroup devices"]
    pub fn libwacom_compare(
        a: *const WacomDevice,
        b: *const WacomDevice,
        flags: WacomCompareFlags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return The class of the device\n\n @deprecated This function should no longer be used. The classes are not\n fine-grained or reliable enough to be useful.\n\n @ingroup devices"]
    pub fn libwacom_get_class(device: *const WacomDevice) -> WacomClass;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return The human-readable name for this device\n\n @ingroup devices"]
    pub fn libwacom_get_name(device: *const WacomDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return The vendor-specific model name (e.g. CTE-650 for a Bamboo Fun), or NULL if none is set\n\n @ingroup devices"]
    pub fn libwacom_get_model_name(device: *const WacomDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return The full filename including path to the SVG layout of the device\n if available, or NULL otherwise\n\n @ingroup devices"]
    pub fn libwacom_get_layout_filename(
        device: *const WacomDevice,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return The numeric vendor ID for this device\n\n @bug The return value is a signed int but libwacom_match_get_vendor_id()\n returns an unsigned int. This may cause compiler warnings, but the\n effective range for vendor IDs is 16-bit only anyway.\n\n @ingroup devices"]
    pub fn libwacom_get_vendor_id(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return The current match string used for this device (if set) or the first\n match string in the tablet definition.\n\n @ingroup devices"]
    pub fn libwacom_get_match(device: *const WacomDevice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return A pointer to the null-terminated list of possible matches for this device. Do not\n modify this pointer or any content!\n\n @ingroup devices"]
    pub fn libwacom_get_matches(device: *const WacomDevice) -> *mut *const WacomMatch;
}
extern "C" {
    #[doc = " Return the match string of the paired device for this device. A paired\n device is a device with a different match string but that shares the\n physical device with this device.\n\n If the return value is NULL, no device is paired with this device or all\n paired devices have the same WacomMatch as this device.\n\n The returned device may not be a libwacom device itself.\n\n @param device The tablet to query\n @return A pointer to paired device for this device. Do not\n modify this pointer or any content!\n\n @ingroup devices"]
    pub fn libwacom_get_paired_device(device: *const WacomDevice) -> *const WacomMatch;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return The numeric product ID for this device\n\n @bug The return value is a signed int but libwacom_match_get_product_id()\n returns an unsigned int. This may cause compiler warning, but the\n effective range for product IDs is 16-bit only anyway.\n\n @ingroup devices"]
    pub fn libwacom_get_product_id(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the width of the device. This is the width of the usable area as\n advertised, not the total size of the physical tablet. For e.g. an\n Intuos4 6x9 this will return 9.\n\n @param device The tablet to query\n @return The width of this device in inches\n\n @ingroup devices"]
    pub fn libwacom_get_width(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the height of the device. This is the height of the usable area as\n advertised, not the total size of the physical tablet. For e.g. an\n Intuos4 6x9 this will return 6.\n\n @param device The tablet to query\n @return The width of this device in inches\n\n @ingroup devices"]
    pub fn libwacom_get_height(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return non-zero if the device supports styli or zero otherwise\n\n @ingroup devices"]
    pub fn libwacom_has_stylus(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return non-zero if the device supports touch or zero otherwise\n\n @ingroup devices"]
    pub fn libwacom_has_touch(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tablet buttons are numbered 'A' through to 'A' + number of buttons.\n\n @param device The tablet to query\n @return The number of buttons on the tablet\n\n @ingroup devices"]
    pub fn libwacom_get_num_buttons(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @param num_styli Return location for the number of listed styli\n @return an array of Styli IDs supported by the device\n\n @ingroup styli"]
    pub fn libwacom_get_supported_styli(
        device: *const WacomDevice,
        num_styli: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return non-zero if the device has a touch ring or zero otherwise\n\n @ingroup devices"]
    pub fn libwacom_has_ring(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return non-zero if the device has a second touch ring or zero otherwise\n\n @ingroup devices"]
    pub fn libwacom_has_ring2(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return non-zero if the device has a touch switch or zero otherwise\n\n @ingroup devices"]
    pub fn libwacom_has_touchswitch(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return the number of modes for the touchring if it has a mode switch\n\n @ingroup devices"]
    pub fn libwacom_get_ring_num_modes(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return the number of modes for the second touchring if it has a mode switch\n\n @ingroup devices"]
    pub fn libwacom_get_ring2_num_modes(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return the number of touch strips on the tablet\n otherwise\n\n @ingroup devices"]
    pub fn libwacom_get_num_strips(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return the number of modes for each of the touchstrips if any\n\n @ingroup devices"]
    pub fn libwacom_get_strips_num_modes(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @param num_leds Return location for the number of supported status LEDs\n @return an array of status LEDs supported by the device\n\n @ingroup devices"]
    pub fn libwacom_get_status_leds(
        device: *const WacomDevice,
        num_leds: *mut ::std::os::raw::c_int,
    ) -> *const WacomStatusLEDs;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @param button The ID of the button to check for, between 'A' and 'Z'\n @return the status LED group id to use\n or -1 if no LED is available for the given tablet / button\n\n @ingroup devices"]
    pub fn libwacom_get_button_led_group(
        device: *const WacomDevice,
        button: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return non-zero if the device is built into the screen (ie a screen tablet)\n or zero if the device is an external tablet\n @deprecated 0.7 Use libwacom_get_integration_flags() instead.\n\n @ingroup devices"]
    pub fn libwacom_is_builtin(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return non-zero if the device can be used left-handed\n (rotated 180 degrees)\n\n @ingroup devices"]
    pub fn libwacom_is_reversible(device: *const WacomDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return the integration flags for the device\n\n @ingroup devices"]
    pub fn libwacom_get_integration_flags(device: *const WacomDevice) -> WacomIntegrationFlags;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @return The bustype of this device.\n\n @ingroup devices"]
    pub fn libwacom_get_bustype(device: *const WacomDevice) -> WacomBusType;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @param button The ID of the button to check for, between 'A' and 'Z'\n @return a WacomButtonFlags with information about the button\n\n @ingroup devices"]
    pub fn libwacom_get_button_flag(
        device: *const WacomDevice,
        button: ::std::os::raw::c_char,
    ) -> WacomButtonFlags;
}
extern "C" {
    #[doc = " @param device The tablet to query\n @param button The ID of the button to check for, between 'A' and 'Z'\n @return The evdev event code sent when the button is pressed or 0 if\n unknown.\n\n @ingroup devices"]
    pub fn libwacom_get_button_evdev_code(
        device: *const WacomDevice,
        button: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the WacomStylus for the given tool ID.\n\n @param db A Tablet and Stylus database.\n @param id The Tool ID for this stylus\n @return A WacomStylus representing the stylus. Do not free.\n\n @ingroup styli"]
    pub fn libwacom_stylus_get_for_id(
        db: *const WacomDeviceDatabase,
        id: ::std::os::raw::c_int,
    ) -> *const WacomStylus;
}
extern "C" {
    #[doc = " @param stylus The stylus to query\n @return the ID of the tool\n\n @ingroup styli"]
    pub fn libwacom_stylus_get_id(stylus: *const WacomStylus) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param stylus The stylus to query\n @return The name of the stylus\n\n @ingroup styli"]
    pub fn libwacom_stylus_get_name(stylus: *const WacomStylus) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @param stylus The stylus to query\n @param num_paired_ids The length of the returned list\n @return The list of other IDs paired to this stylus\n\n @ingroup styli"]
    pub fn libwacom_stylus_get_paired_ids(
        stylus: *const WacomStylus,
        num_paired_ids: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param stylus The stylus to query\n @return The number of buttons on the stylus\n\n @ingroup styli"]
    pub fn libwacom_stylus_get_num_buttons(stylus: *const WacomStylus) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the given stylus is paired with a separate eraser.\n\n If this function returns @c true then the tool described by the given\n WacomStylus is paired with a separate eraser tool. The actual eraser\n tool may be located by iterating over the list of paired styli.\n\n @param stylus The stylus to query\n @return Whether the stylus is paired with an eraser\n @see libwacom_stylus_get_paired_ids\n @see libwacom_stylus_is_eraser\n\n @ingroup styli"]
    pub fn libwacom_stylus_has_eraser(stylus: *const WacomStylus) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the given stylus may act like an eraser.\n\n If this function returns @c true then the tool described by the given\n WacomStylus may act like an eraser. Such a tool may be dedicated to\n sending just eraser events (and paired with a separate tool for \"tip\"\n events) or capable of sending both both tip and eraser events.\n\n @param stylus The stylus to query\n @return Whether the stylus can act as an eraser\n @see libwacom_stylus_get_eraser_type\n @see libwacom_stylus_has_eraser\n\n @ingroup styli"]
    pub fn libwacom_stylus_is_eraser(stylus: *const WacomStylus) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param stylus The stylus to query\n @return Whether the stylus has a lens\n\n @ingroup styli"]
    pub fn libwacom_stylus_has_lens(stylus: *const WacomStylus) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param stylus The stylus to query\n @return Whether the stylus has a relative mouse wheel\n\n @ingroup styli"]
    pub fn libwacom_stylus_has_wheel(stylus: *const WacomStylus) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param stylus The stylus to query\n @return The flags specifying the list of absolute axes\n\n @ingroup styli"]
    pub fn libwacom_stylus_get_axes(stylus: *const WacomStylus) -> WacomAxisTypeFlags;
}
extern "C" {
    #[doc = " @param stylus The stylus to query\n @return The type of stylus\n\n @ingroup styli"]
    pub fn libwacom_stylus_get_type(stylus: *const WacomStylus) -> WacomStylusType;
}
extern "C" {
    #[doc = " @param stylus The stylus to query\n @return The type of eraser on the stylus\n\n @ingroup styli"]
    pub fn libwacom_stylus_get_eraser_type(stylus: *const WacomStylus) -> WacomEraserType;
}
extern "C" {
    #[doc = " Print the description of this stylus to the given file.\n\n @param fd The file descriptor\n @param stylus The stylus to print the description for.\n\n @ingroup styli"]
    pub fn libwacom_print_stylus_description(fd: ::std::os::raw::c_int, stylus: *const WacomStylus);
}
extern "C" {
    #[doc = " @addtogroup devices\n @{"]
    pub fn libwacom_match_get_name(match_: *const WacomMatch) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn libwacom_match_get_bustype(match_: *const WacomMatch) -> WacomBusType;
}
extern "C" {
    pub fn libwacom_match_get_product_id(match_: *const WacomMatch) -> u32;
}
extern "C" {
    pub fn libwacom_match_get_vendor_id(match_: *const WacomMatch) -> u32;
}
extern "C" {
    pub fn libwacom_match_get_match_string(
        match_: *const WacomMatch,
    ) -> *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
